--- sanlock-2.5/init.d/sanlock.orig	2012-09-30 10:16:54.308331928 +0200
+++ sanlock-2.5/init.d/sanlock	2012-09-30 10:51:21.691622171 +0200
@@ -32,95 +32,86 @@
 [ -f /etc/sysconfig/$prog ] && . /etc/sysconfig/$prog
 
 start() {
-	[ -x $exec ] || exit 5
-
-	if [ ! -d /var/run/$prog ]; then
-		install -d -o $SANLOCKUSER -g $SANLOCKUSER -m 775 /var/run/$prog
-		[ -x /sbin/restorecon ] && restorecon /var/run/$prog
+	# Check if the service is already running?
+	if [ -f /var/lock/subsys/sanlock ]; then
+		msg_already_running "sanlock"
+		return
 	fi
 
-	echo -n $"Starting $prog: "
+	msg_starting "sanlock"
 	daemon $prog daemon $SANLOCKOPTS
 	retval=$?
-	echo
 	[ $retval -eq 0 ] && touch $lockfile
 	return $retval
 }
 
 stop() {
+	if [ ! -f /var/lock/subsys/sanlock ]; then
+		msg_not_running "sanlock"
+		return
+	fi
 	PID=$(pidofproc -p $runfile $prog)
 
-	echo -n $"Sending stop signal $prog ($PID): "
 	killproc -p $runfile $prog -TERM
 	retval=$?
-	echo
 
 	if [ $retval -ne 0 ]; then
 		return $retval
 	fi
 
-	echo -n $"Waiting for $prog ($PID) to stop:"
+	show "Waiting for %s (%s) to stop:" "$prog" "$PID"
+	busy
 
 	timeout=10
 	while checkpid $PID; do
 		sleep 1
 		timeout=$((timeout - 1))
 		if [ "$timeout" -le 0 ]; then
-			failure; echo
-			return 1
+			fail
+			retval=1
+			return $retval
 		fi
 	done
 
-	success; echo
+	ok
 	rm -f $lockfile
 	return $retval
 }
 
-restart() {
-	rh_status_q && stop
-	start
-}
-
-reload() {
-	restart
-}
-
-rh_status() {
-	status $prog
-}
-
-rh_status_q() {
-	rh_status >/dev/null 2>&1
+condrestart() {
+	if [ ! -f /var/lock/subsys/sanlock ]; then
+		msg_not_running "sanlock"
+		retval=$1
+		return $retval
+	fi
+	stop && start
+	retval=$?
+	return $retval
 }
 
 case "$1" in
 	start)
-		rh_status_q && exit 0
-		$1
+		start
 		;;
 	stop)
-		rh_status_q || exit 0
-		$1
+		stop
 		;;
 	restart)
-		$1
+		stop
+		start
 		;;
-	reload)
-		rh_status_q || exit 7
-		$1
+	try-restart)
+		condrestart 0
 		;;
 	force-reload)
-		force_reload
+		condrestart 7
 		;;
 	status)
-		rh_status
-		;;
-	condrestart|try-restart)
-		rh_status_q || exit 0
-		restart
+		status --pidfile $runfile sanlock
+		retval=$?
 		;;
 	*)
-		echo $"Usage $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
-		exit 2
+		msg_usage "$0 {start|stop|status|restart||try-restart|force-reload}"
+		exit 3
 esac
-exit $?
+exit $retval
--- sanlock-2.5/init.d/wdmd.orig	2012-09-24 17:35:09.000000000 +0200
+++ sanlock-2.5/init.d/wdmd	2012-09-30 10:51:00.684955942 +0200
@@ -3,7 +3,7 @@
 # wdmd - watchdog multiplexing daemon
 #
 # chkconfig: 2345 97 03
-# description: starts and stops sanlock daemon
+# description: starts and stops wdmd daemon
 #
 
 
@@ -33,105 +33,92 @@
 
 watchdog_check() {
 	if [ ! -c /dev/watchdog ]; then
-		echo -n $"Loading the softdog kernel module: "
+		show "Loading the softdog kernel module: "
 		modprobe softdog && udevadm settle
-		[ -c /dev/watchdog ] && success || failure
-		echo
+		[ -c /dev/watchdog ] && ok || fail
 	fi
 }
 
 start() {
+	# Check if the service is already running?
+	if [ -f /var/lock/subsys/wdmd ]; then
+		msg_already_running "wdmd"
+		return
+ 	fi
+ 
 	watchdog_check
 
-	[ -x $exec ] || exit 5
-
-	if [ ! -d /var/run/$prog ]; then
-		install -d -g $WDMDGROUP -m 775 /var/run/$prog
-		[ -x /sbin/restorecon ] && restorecon /var/run/$prog
-	fi
-
-	echo -n $"Starting $prog: "
+	msg_starting "wdmd"
 	daemon $prog $WDMDOPTS
 	retval=$?
-	echo
 	[ $retval -eq 0 ] && touch $lockfile
 	return $retval
 }
 
 stop() {
+	if [ ! -f /var/lock/subsys/wdmd ]; then
+		msg_not_running "wdmd"
+		return
+	fi
 	PID=$(pidofproc -p $runfile $prog)
 
-	echo -n $"Sending stop signal $prog ($PID): "
 	killproc -p $runfile $prog -TERM
 	retval=$?
-	echo
 
 	if [ $retval -ne 0 ]; then
 		return $retval
 	fi
 
-	echo -n $"Waiting for $prog ($PID) to stop:"
+	show "Waiting for %s (%s) to stop:" "$prog" "$PID"
 
 	timeout=10
 	while checkpid $PID; do
 		sleep 1
 		timeout=$((timeout - 1))
 		if [ "$timeout" -le 0 ]; then
-			failure; echo
-			return 1
+			fail
+			retval=1
+			return $retval
 		fi
 	done
 
-	success; echo
+	ok
 	rm -f $lockfile
 	return $retval
 }
 
-restart() {
-	rh_status_q && stop
-	start
-}
-
-reload() {
-	restart
-}
-
-rh_status() {
-	status $prog
-}
-
-rh_status_q() {
-	rh_status >/dev/null 2>&1
+condrestart() {
+	if [ ! -f /var/lock/subsys/wdmd ]; then
+		msg_not_running "wdmd"
+		retval=$1
+		return
+	fi
+ 	stop
+ 	start
 }
 
 case "$1" in
 	start)
-		rh_status_q && exit 0
-		$1
+		start
 		;;
 	stop)
-		rh_status_q || exit 0
-		$1
+		stop
 		;;
 	restart)
-		$1
-		;;
-	reload)
-		rh_status_q || exit 7
-		$1
+		stop
+		start
 		;;
 	force-reload)
-		force_reload
+		condrestart 7
 		;;
-	status)
-		rh_status
+	try-restart)
+		condrestart 0
 		;;
-	condrestart|try-restart)
-		rh_status_q || exit 0
-		restart
+	status)
+		status --pidfile $runfile wdmd
 		;;
 	*)
-		echo $"Usage $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
+		msg_usage "$0 {start|stop|status|restart|try-restart|force-reload}"
 		exit 2
 esac
-exit $?
+exit $retval
